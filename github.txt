1. 형상관리 시스템(SCM: Source Code Management)
 - 프로젝트의 시작부터 끝까지 모든 변동상황을 관리하는 작업.

형상관리 꼭 필요한가?
 - 프로젝트의 진행을 위해서. -> 개발과정의 기록 및 사고 예방
 - 형상관리는 프로젝트가 원활히 진행됐을 때는 문제가 없지만
   프로젝트가 잘못됐을 경우는 굉장히 다른 방향으로 사용
 - 프로젝트가 진행되는 도중에는 누구나 실수 할 수 있음
   (문제가 발생했을 때는 해결이 우선)

형상관리는 완벽한가?
 - 통제의 어려움
 - 무절제한 병경에 취약
 - 버전관리는 편하긴함

형상관리의 장점
 - 배포가 편리
 - 편리한 버전관리
 - 충돌 방지에 유용(최소화 / 완벽방어는 아님)
 - 작업 효율 상승

형상관리 구성
 1. 기준선
     - 각 형상 항목들의 기술적 통제 시점
     - 모든 변화를 통제하는 시점의 기준선
 1-1. 기준선의 종류
     - 기능적 기준선 : 수행계획서(착수보고서), 요구사항 정의서(관리대장), 기능 구조도
     - 분배적 기준선 : 엔티티 정의서, 데이터 흐름도, 용어집
     - 설계 기준선 : 인터페이스 설계서, ERD 설계서, UI 설계서(정의서), 유스케이스 설계서
     - 시험 기준선 : 단위테스트. 통합테스트 시나리오(단위테스트 관리대장, 소스코드 관리대장)
        기능 테스트 횟수는 최소 1000회는 한다 생각.
     - 제품 기준선 : 통합테스트 시나리오
     - 운영 기준선 : 사용자/운영자 메뉴얼, 최종산출물(종료보고서)

 프로젝트 수행단계 

 착수 -> 기획/분석 -> 설계 -> 구현 -> 테스트 -> 오픈

 2. 형상 항목
  - 프로젝트에서 공식적으로 정의되어 관리되는 모든 대상
 
 3. 형상 버전
  - 기준선을 설정한 후 일어난 변경의 고유 식별번호
  - 식별명과 버전으로 시스템 구성요소를 하나로 식별

 4. 형상 제품
  - 형상의 항목 대상이 되는 제품

형상관리? 버전관리?
 - 일반적으로는 형상관리 = 버전관리

형상관리(버전관리)를 통해 기대효과
 - 백업, 복구도 유용하게
 - 환경만 연결되어 있으면 어디서나도 가능할 수 있음
 - 버전관리를 통해서 원하는 시점으로 다시 돌아가는 것도 가능

버전관리 종류
1. 로컬 버전관리 시스템 (개인 컴퓨터)
2. 중앙집중식 버전관리 시스템 (서버는 한 개 여러 명의 클라이언트)
    - 사용자 관리, 서버관리가 용이하다
    - 중앙서버가 문제가 생기면 큰일난다
3. 분산 버전관리 시스템(서버도 여러 개 여러 명의 클라이언트)

형상관리 틀의 종류
 - git, svn, cvs

1. CVS
 - 중앙 저장소가 존재하고 그 중앙저장소에 모든 사용자가 접근할 수 있도록 설계된 형상관리 시스템
 - 시스템이 굉장히 안정적
 - 이력관리 당연히 가능
 - 단점은 코드를 업로드 하다가 오류가 발생하면 되돌리는 것(롤백)은 불가능

2. SVN - (redmine)
 - 커밋이 엉킬일은 없음(다른 사용자와 중첩 X)
 - 실패시 롤백 기능을 지원
 - 속도가 빠르고 개별 버전 관리가 가능
 - 안정성이 많이 떨어짐 히스토리 관리가 쉽지 않음

3. GIT
 - 저장소 원본 자체를 로컬에 저장할 수 있음
 - 처리속도가 빠름, 작업 이력관리가 쉬움
 - 커밋한 내용도 수정 가능
 - 장소에 구애받지 않음(인터넷만 가능 + 권한이 있으면 접근 가능)

git 저장소생성(초기화)
git init

저장소를 처음 쓸 때에는 유저 등록이 필요
global은 본인만 사용하는 pc라면 따로 등록할 필요가 없어서 다른 저장소로 붙을 때에도 편리함
git config --global user.email "이메일주소"
git config --global user.name "이름"

등록 후 제대로 등록되었는지 확인
git config --list

등록이 잘못되었을 경우(삭제)
git config --unset --global user.email "이메일주소"
git config --unset --global user.name "이름"

형상관리가 진행되는 폴더 -> 작업트리(working tree)
 - 파일의 수정, 저장 등의 작업을 하는 디렉토리
 - 스테이지를 거쳐 깃 저장소로 이동

스테이지 : 버전으로 만들 파일들이 대기하는 장소
 - 파일 하나하나가 작업트리로 생성. 이 중 몇개만 보내고 싶으면  그 해당하는 파일들만 넘겨주면 된다
 - 작업 트리가 10개 생성됐다 가정하고 4개만 등록하고 싶으면 4개만 넘겨주면 됨

스테이지에 파일 추가
 git add 파일명(* / 전부 다)

스테이지 확인(업로드된 파일 확인)
 git status

git repository로 commit
 git commit -m "커밋메세지"

github로 업로드 시도
remote 설정

처음 연결
 git remote add origin "레포지토리주소"

 github 업로드(push)

 git push origin(리모트명) main(브랜치명)
  - 잘 안됐을 경우 git branch로 브랜치명이 맞는지 확인
  - 안맞다면 git branch -m 이전브랜치명 새로운브랜치명  => 이걸 통해 브랜치명 바꾸기

git pull 해도 실행 안될 경우
  git push origin +main 을 통해 덮어쓰기를 진행한다.


 깃 작업 트리 영역

작업 디렉토리 : 실제 작업 중인 파일들이 존재하는 영역
   -> add
스테이징 영역 : 작업 디렌토리에서 작업 중인 파일 중에 깃이 추적하는 파일들을 식별하는 영역
   -> commit
로컬 repository(git repository) : 스테이징 영역에서 추적되는 파일이 커밋으로 등록되는 영역에서

git의 파일상태 확인
 - Untracked : git에서 변화를 감지하지 못한 파일
 - Tracked : git에서 변화를 감지한 파일

커밋
 -m 이후 작성될 메시지는 히스토리 추적을 용이하게 돕는 역할을 할 수 있음

GitHub 용어
1. remote(리모트)
 - 인터넷이나 네트워크 어딘가에 있는 저장소 
   git remote add origin '주소'
 - 이름: origin -> 자주 사용하는 별칭

2. branch(브랜치) : 독립된 작업공간
   - 독립된 작업공간을 통해 동일한 프로젝트를 기반으로도 서로 다른 버전의
     코드를 만들어 낼 수 있다는 장점이 있음
   - 서로의 코드에 영향을 주고받지 않고 싶어서 만들어진 개념

   HEAD : 브랜치가 바라보는 영역
   
   bransh 생성방법
   1. github에서 생성 후에 로컬로 가져오기
   2. 로컬에서 생성 후 github에 반영하기

3. fetch - 원격 저장소(github repository)의 내용을 확인하면서
           아직 로컬데이터와의 병합은 진행하고 싶지 않은 경우 사용되는 명령어(개념)
         - 원격 저장소의 최신 이력을 확인, 
           가져온 최신 커밋 이력은 이름없는 브랜치로 로컬에서 가져옴
           ->FETCH_HEAD 이름으로 체크아웃
           fetch + merge = pull

4. clone - 원격 저장소 복사(원격 저장소의 내용을 통째로 다운로드)
         - 변경 이력도 함께 로컬 저장소에 복제 되서 들어옴
         - 원래 원격 저장소와 똑같이 이력을 참조하고 커밋 진행이 가능

5. reset, revert, rebase
   reset :  되돌리기, 이력을 남기지 않는다(히스토리)
            ->git reset 옵션 돌아갈커밋영역 => 돌아가려는 이력으로 레퍼지토리 재설정

   revert : 되돌리기, 이력을 유지해준다(히스토리)
            ->상태 되돌리기
   
   rebase : 이력 재정리(브랜치 이력) 
            ->히스토리 관리가 별로 필요없다 판단된다면 merge보다 나을 수 있음

   merge : 병합
           ->브랜치를 하나로 통합할 수 있음
           ->내가 끌어온 원격 저장소가 최신버전이 아니라면 push 요청이 거부될 수 있음
           ->다른 사람의 업데이트 이력조차 내 저장소와 공유(갱신되면 같이 갱신)
   
   checkout : 브랜치 전환 시 사용되는 명령어